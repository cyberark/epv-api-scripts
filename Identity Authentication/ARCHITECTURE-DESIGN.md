# Identity Authentication Module - Architecture Design

## Table of Contents
1. [Process Flow Diagrams](#process-flow-diagrams)
2. [Class Structure Diagrams](#class-structure-diagrams)
3. [Module Structure](#module-structure)
4. [Session State Management](#session-state-management)
5. [Return Value Structure](#return-value-structure)
6. [Security Architecture](#security-architecture)

---

## Process Flow Diagrams


### 1. Standard Challenge Flow (UP/OTP/Push)

```mermaid
flowchart TD
    Start([Standard Authentication]) --> StartAuth[POST /Security/StartAuthentication<br/>Body: User, Version]
    StartAuth --> ParseResponse[Parse response:<br/>- SessionId<br/>- Challenges array]

    ParseResponse --> IterateChallenges[Iterate through Challenges]
    IterateChallenges --> GetMechanisms[Extract Mechanisms array<br/>from current challenge]

    GetMechanisms --> CountMechanisms{How many<br/>mechanisms?}

    CountMechanisms -->|Multiple| DisplayMenu[Display numbered menu:<br/>1. Mechanism1<br/>2. Mechanism2<br/>...]
    DisplayMenu --> PromptSelection[Prompt user to select 1-N]
    PromptSelection --> ValidateSelection{Valid<br/>selection?}
    ValidateSelection -->|No| PromptSelection
    ValidateSelection -->|Yes| SelectMechanism[Select mechanism from array]

    CountMechanisms -->|Single| SelectMechanism

    SelectMechanism --> CheckAnswerType{Mechanism<br/>AnswerType?}

    CheckAnswerType -->|Text| CheckMechName{Mechanism<br/>Name?}
    CheckMechName -->|UP| CheckStoredCreds{UPCreds<br/>parameter?}
    CheckStoredCreds -->|Yes| ExtractPassword[Extract password<br/>from PSCredential]
    CheckStoredCreds -->|No| PromptPassword[Prompt for password<br/>as SecureString]

    ExtractPassword --> BuildAnswerBody[Build AdvanceAuth body:<br/>SessionId<br/>MechanismId<br/>Action: Answer<br/>Answer: password]
    PromptPassword --> BuildAnswerBody

    CheckMechName -->|OTP| PromptOTP[Prompt for OTP code]
    PromptOTP --> BuildAnswerBody

    CheckMechName -->|Other| PromptAnswer[Prompt for answer]
    PromptAnswer --> BuildAnswerBody

    CheckAnswerType -->|StartTextOob| InitiatePush[Build AdvanceAuth body:<br/>Action: StartOOB]
    InitiatePush --> PostStartOOB[POST /Security/AdvanceAuthentication]
    PostStartOOB --> DisplayPushMsg[Output: Waiting for push approval...]
    DisplayPushMsg --> PollLoop[Build poll body:<br/>Action: Poll]

    PollLoop --> PostPoll[POST /Security/AdvanceAuthentication]
    PostPoll --> CheckPollStatus{Response<br/>Summary?}
    CheckPollStatus -->|OobPending| Wait[Wait 2 seconds]
    Wait --> PollLoop
    CheckPollStatus -->|LoginSuccess| PushApproved[Push approved]
    CheckPollStatus -->|Error/Timeout| PushFailed[Throw: Push denied/timeout]

    BuildAnswerBody --> PostAnswer[POST /Security/AdvanceAuthentication]
    PostAnswer --> CheckAnswerResponse{Response<br/>status?}

    PushApproved --> CheckAnswerResponse

    CheckAnswerResponse -->|Success + Token| ExtractToken[Extract Token from Result]
    CheckAnswerResponse -->|Success + No Token| CheckMoreChallenges{More<br/>challenges<br/>remaining?}
    CheckAnswerResponse -->|Failure| AuthFailed[Throw authentication error]

    CheckMoreChallenges -->|Yes| IterateChallenges
    CheckMoreChallenges -->|No| AuthFailed

    ExtractToken --> StoreSession[Store in $script:CurrentSession]
    StoreSession --> FormatHeaders[Format authorization headers]
    FormatHeaders --> ReturnHeaders[Return headers/object]

    ReturnHeaders --> End([End])
    AuthFailed --> End
    PushFailed --> End
```

### 2. OOBAUTHPIN Authentication Flow

```mermaid
flowchart TD
    Start([User calls Get-IdentityHeader]) --> SetHeaders[Set Headers:<br/>OobIdPAuth=true<br/>X-IDAP-NATIVE-CLIENT=true]
    SetHeaders --> StartAuth[POST /Security/StartAuthentication<br/>Body: User, Version]
    StartAuth --> CheckShortURL{IdpRedirectShortUrl<br/>present?}

    CheckShortURL -->|Yes| ExtractData[Extract:<br/>- IdpRedirectShortUrl<br/>- IdpLoginSessionId<br/>- SessionId]
    CheckShortURL -->|No| FallbackFlow[Fall back to<br/>standard challenge flow]

    ExtractData --> DisplayInstructions[Display formatted instructions:<br/>Steps to open URL<br/>Complete SAML<br/>Receive PIN]
    DisplayInstructions --> WaitSAML[Wait for user to<br/>complete SAML in browser]

    WaitSAML --> PromptPIN[Prompt user for PIN<br/>generated by IDP]

    PromptPIN --> ValidatePIN{PIN valid<br/>numeric?}
    ValidatePIN -->|No| PromptPIN
    ValidatePIN -->|Yes| SubmitPIN[POST /Security/AdvanceAuthentication<br/>SessionId: IdpLoginSessionId<br/>MechanismId: OOBAUTHPIN<br/>Action: Answer<br/>Answer: PIN]

    SubmitPIN --> CheckResponse{Response<br/>status?}
    CheckResponse -->|Success + Token| ExtractToken[Extract token from response]
    CheckResponse -->|Success + More Challenges| NextChallenge[Recursively call<br/>Invoke-Challenge]
    CheckResponse -->|Error| AuthFailed[Throw authentication error]

    NextChallenge --> ProcessChallenge[Process additional challenge]
    ProcessChallenge --> CheckToken{Token<br/>received?}
    CheckToken -->|Yes| ExtractToken
    CheckToken -->|No| AuthFailed

    ExtractToken --> StoreSession[Store in $script:CurrentSession:<br/>- Token<br/>- TokenExpiry<br/>- IdentityURL<br/>- AuthMethod: OOBAUTHPIN]
    StoreSession --> FormatHeaders[Format return headers:<br/>Authorization: Bearer token<br/>X-IDAP-NATIVE-CLIENT: true]
    FormatHeaders --> ReturnHeaders[Return Dictionary]

    FallbackFlow --> StandardFlow[Process via<br/>Invoke-Challenge]
    StandardFlow --> End
    ReturnHeaders --> End
    AuthFailed --> End
```

### 3. OAuth Authentication Flow

```mermaid
flowchart TD
    Start([OAuth Authentication]) --> CheckSession{ForceNewSession<br/>or no session?}
    CheckSession -->|Use existing| CheckExpiry{Token<br/>expired?}
    CheckExpiry -->|No| ReturnExisting[Return current session]
    CheckExpiry -->|Yes| AttemptRefresh[Attempt auto-refresh]

    CheckSession -->|New session| ValidateCreds{OAuth credentials<br/>provided?}
    ValidateCreds -->|No| ErrorNoCreds[Throw: Credentials required]
    ValidateCreds -->|Yes| ExtractCreds[Extract ClientID and ClientSecret<br/>from PSCredential/params]

    ExtractCreds --> GetIdentityURL[Get Identity URL<br/>from PCloud URL]
    GetIdentityURL --> BuildRequest[Build OAuth request:<br/>grant_type=client_credentials<br/>client_id=ClientID<br/>client_secret=ClientSecret]

    BuildRequest --> PostRequest["POST /OAuth2/Token/ClientId<br/>Content-Type: application/x-www-form-urlencoded"]
    PostRequest --> CheckResponse{HTTP<br/>Status?}

    CheckResponse -->|200 OK| ParseToken[Parse response:<br/>- access_token<br/>- token_type<br/>- expires_in]
    CheckResponse -->|401| ErrorInvalidCreds[Throw: Invalid credentials]
    CheckResponse -->|Other| ErrorAPI[Throw: API error]

    ParseToken --> CalculateExpiry[Calculate expiry:<br/>now + expires_in seconds]
    CalculateExpiry --> StoreSession[Store in $script:CurrentSession:<br/>- Token<br/>- TokenExpiry<br/>- IdentityURL<br/>- PCloudURL<br/>- AuthMethod: OAuth<br/>- StoredCredentials]

    StoreSession --> BuildHeader[Build authorization header:<br/>Bearer access_token]
    BuildHeader --> BuildDict[Build Dictionary:<br/>Authorization<br/>X-IDAP-NATIVE-CLIENT]
    BuildDict --> ReturnStandard[Return Dictionary]

    AttemptRefresh --> CheckStoredCreds{OAuth creds<br/>in session?}
    CheckStoredCreds -->|Yes| ReAuth[Re-authenticate<br/>with stored creds]
    CheckStoredCreds -->|No| ErrorNoRefresh[Throw: Cannot auto-refresh]

    ReAuth --> CheckReAuthSuccess{Re-auth<br/>success?}
    CheckReAuthSuccess -->|Yes| UpdateSession[Update session:<br/>- New token<br/>- New expiry<br/>- Increment RefreshCount]
    CheckReAuthSuccess -->|No| ErrorReAuthFailed[Throw: Refresh failed]

    UpdateSession --> BuildDict
    ReturnExisting --> End([End])
    ReturnStandard --> End
    ErrorNoCreds --> End
    ErrorInvalidCreds --> End
    ErrorAPI --> End
    ErrorNoRefresh --> End
    ErrorReAuthFailed --> End
```

### 4. Token Refresh Logic Flow

```mermaid
flowchart TD
    Start([Get-IdentityHeader called]) --> CheckForceNew{ForceNewSession<br/>parameter?}
    CheckForceNew -->|Yes| ClearSession[Clear current session]
    ClearSession --> NormalAuth[Proceed with normal auth]

    CheckForceNew -->|No| CheckSession{$script:CurrentSession<br/>exists?}
    CheckSession -->|No| NormalAuth
    CheckSession -->|Yes| GetExpiry[Get TokenExpiry from session]

    GetExpiry --> CalculateRemaining[Calculate time until expiry]
    CalculateRemaining --> CheckExpiry{Token<br/>status?}

    CheckExpiry -->|Expired| LogExpired[Write-Verbose: Token expired]
    LogExpired --> CheckAuthMethod{AuthMethod?}

    CheckExpiry -->|Expiring soon<br/>less than 60 sec| ShowWarning[Write-Warning:<br/>Token expiring soon]
    ShowWarning --> CheckAuthMethod

    CheckExpiry -->|Valid<br/>more than 60 sec| LogValid[Write-Verbose: Using existing token]
    LogValid --> ReturnCurrent[Return current session headers]

    CheckAuthMethod -->|OAuth| CheckStoredCreds{OAuth creds<br/>stored in session?}
    CheckStoredCreds -->|Yes| LogRefresh[Write-Verbose: Auto-refreshing OAuth token]
    LogRefresh --> ExtractCreds[Extract ClientID and ClientSecret<br/>from StoredCredentials]

    ExtractCreds --> BuildOAuthRequest[Build OAuth token request]
    BuildOAuthRequest --> PostOAuth["POST /OAuth2/Token/ClientId"]
    PostOAuth --> CheckOAuthResponse{OAuth<br/>success?}

    CheckOAuthResponse -->|Yes| UpdateToken[Update session:<br/>- New Token<br/>- New TokenExpiry<br/>- LastRefreshed timestamp<br/>- Increment RefreshCount]
    CheckOAuthResponse -->|No| LogOAuthFailed[Write-Verbose: OAuth refresh failed]
    LogOAuthFailed --> ThrowRefreshError[Throw: Failed to refresh token]

    UpdateToken --> LogRefreshSuccess[Write-Verbose: Token refreshed successfully]
    LogRefreshSuccess --> ReturnRefreshed[Return refreshed session headers]

    CheckStoredCreds -->|No| LogNoStoredCreds[Write-Verbose: No stored credentials]
    LogNoStoredCreds --> ThrowNoCredsError[Throw: Cannot auto-refresh]

    CheckAuthMethod -->|UP/MFA/Other| LogMFARequired[Write-Warning: Manual re-auth required<br/>MFA cannot auto-refresh]
    LogMFARequired --> ClearExpiredSession[Clear expired session]
    ClearExpiredSession --> NormalAuth

    NormalAuth --> AuthProcess[Execute full authentication<br/>as per authentication method]
    AuthProcess --> End([End])
    ReturnCurrent --> End
    ReturnRefreshed --> End
    ThrowRefreshError --> End
    ThrowNoCredsError --> End
```

---

## Class Structure Diagrams

**Class Diagram Legend:**
- `+` = **Public** (accessible from outside the class)
- `-` = **Private** (only accessible within the class)
- `#` = **Protected** (accessible within class and subclasses)

### 1. Core Classes and Relationships (PowerShell 7)

```mermaid
classDiagram
    class IdentitySession {
        +String Token
        +DateTime TokenExpiry
        +String IdentityURL
        +String PCloudURL
        +String Username
        +String SessionId
        +AuthenticationMechanism AuthMethod
        +PSCredential StoredCredentials
        +Hashtable Metadata
        +IsExpired() bool
        +IsExpiringSoon(int) bool
        +Refresh() void
        +GetAuthHeader() Hashtable
        +Dispose() void
    }

    class IdentityAuthResponse {
        +Bool Success
        +String Message
        +PSCustomObject Result
        +Hashtable ErrorInfo
        +Int StatusCode
        +DateTime Timestamp
        +ToToken() String
        +HasChallenges() bool
    }

    class ChallengeInfo {
        +String ChallengeId
        +Array Mechanisms
        +String Type
        +Hashtable Metadata
        +GetMechanismByName(String) PSCustomObject
        +HasMultipleMechanisms() bool
    }

    class MechanismInfo {
        +String MechanismId
        +String Name
        +String AnswerType
        +String PromptMechChosen
        +Hashtable Properties
        +RequiresUserInput() bool
        +IsOOB() bool
    }

    class SessionManager {
        -IdentitySession CurrentSession
        +GetSession() IdentitySession
        +SetSession(IdentitySession) void
        +ClearSession(bool) void
        +HasActiveSession() bool
        +RefreshIfNeeded() bool
    }

    class TokenValidator {
        +ValidateFormat(String) bool
        +ValidateExpiry(DateTime) bool
        +GetTokenClaims(String) Hashtable
    }

    IdentitySession --> AuthenticationMechanism
    IdentityAuthResponse --> ChallengeInfo
    ChallengeInfo --> MechanismInfo
    SessionManager --> IdentitySession
    TokenValidator --> IdentitySession
```

### 2. Enum Definitions (PowerShell 7)

```mermaid
classDiagram
    class AuthenticationMechanism {
        <<enumeration>>
        UP = 1
        OAuth = 2
        EmailOTP = 3
        SMSOTP = 4
        PushNotification = 5
        SAML_Deprecated = 6
        OOBAUTHPIN = 7
        PhoneCall = 8
        SecurityQuestions = 9
    }

    class ChallengeType {
        <<enumeration>>
        Text = 1
        StartTextOob = 2
        StartOob = 3
        Poll = 4
        Answer = 5
        SAML = 6
    }

    class MechanismType {
        <<enumeration>>
        UP = 1
        OTP = 2
        EMAIL = 3
        SMS = 4
        PF = 5
        OATH = 6
        RADIUS = 7
        SQ = 8
        SAML = 9
    }

    class SessionState {
        <<enumeration>>
        NotAuthenticated = 0
        Authenticating = 1
        Authenticated = 2
        Expired = 3
        RefreshRequired = 4
        Invalid = 5
    }
```

### 3. Private Function Organization

```mermaid
classDiagram
    class PrivateFunctions {
        <<interface>>
    }

    class FormatToken {
        +Execute(String) Hashtable
        -AddNativeClientHeader(Hashtable) void
        -BuildAuthorizationHeader(String) Hashtable
    }

    class InvokeRest {
        +Execute(String, String, Object, Hashtable) Object
        -BuildSplatParams(Hashtable) Hashtable
        -HandleErrors(Exception) void
        -LogRequest(Hashtable) void
        -LogResponse(Object) void
    }

    class InvokeAdvancedAuthBody {
        +Execute(String, PSCustomObject, String) PSCustomObject
        -HandleTextAnswer(PSCustomObject) String
        -HandleOOB(PSCustomObject) PSCustomObject
        -PollForCompletion(String, String) PSCustomObject
    }

    class InvokeChallenge {
        +Execute(PSCustomObject, PSCredential, String) PSCustomObject
        -ParseChallenges(Array) Array
        -SelectMechanism(Array) PSCustomObject
        -ProcessMechanism(PSCustomObject, String) PSCustomObject
    }

    class SessionHelpers {
        +ConvertFrom-SessionToHeaders(IdentitySession) Hashtable
        +New-IdentitySession(Hashtable) IdentitySession
        +Update-IdentitySession(IdentitySession) void
    }

    PrivateFunctions <|-- FormatToken
    PrivateFunctions <|-- InvokeRest
    PrivateFunctions <|-- InvokeAdvancedAuthBody
    PrivateFunctions <|-- InvokeChallenge
    PrivateFunctions <|-- SessionHelpers
```

---

## Module Structure

### Public vs Private Functions

#### Public Functions (Exported to Users)

| Function | Purpose | Key Parameters | Returns |
|----------|---------|----------------|---------|
| `Get-IdentityHeader` | Main authentication entry point | IdentityUserName, UPCreds, OAuthCreds, PIN, ForceNewSession, IdentityTenantURL, PCloudURL | String (Bearer token) |
| `Get-IdentityURL` | Discover Identity URL from PCloud URL | PCloudURL | String (Identity URL) |
| `Test-IdentityToken` | Validate token validity and expiry | Token, IdentityURL | Boolean |
| `Clear-IdentitySession` | Clear current session and optionally logout | NoLogout (switch) | Void |
| `Get-IdentitySession` | Get current session details | None | IdentitySession or Hashtable |

#### Private Functions (Internal Use Only)

| Function | Purpose | Used By |
|----------|---------|---------|
| `Format-Token` | Extract and return Bearer token string | Get-IdentityHeader, token refresh logic |
| `Invoke-Rest` | Make REST API calls with splatting and logging | All API interactions |
| `Invoke-AdvancedAuthBody` | Handle AdvanceAuthentication API | Invoke-Challenge, OOBAUTHPIN flow |
| `Invoke-Challenge` | Process authentication challenges | Get-IdentityHeader (standard flow) |
| `Invoke-OOBAUTHPIN` | Handle OOBAUTHPIN (SAML + PIN) authentication | Get-IdentityHeader (OOBAUTHPIN flow) |
| `ConvertFrom-SessionToHeaders` | Convert session object to headers | Token refresh, existing session reuse |
| `New-IdentitySession` | Create new session object/hashtable | After successful authentication |
| `Update-IdentitySession` | Update session with refreshed token | OAuth token refresh |

### PowerShell 5.1 vs PowerShell 7 Feature Comparison

| Feature | PowerShell 5.1 | PowerShell 7+ | Implementation Strategy |
|---------|----------------|---------------|-------------------------|
| **Classes** | Supported (PS 5.0+) | Fully supported | Use in both, full feature in PS7 |
| **Enums** | Supported | Fully supported | Use in both versions |
| **Ternary Operator** | ❌ Not available | ✅ `$x ? $a : $b` | Use if/else in PS5.1, ternary in PS7 |
| **Null Coalescing** | ❌ Not available | ✅ `$x ?? $default` | Use explicit checks in PS5.1 |
| **Null Conditional** | ❌ Not available | ✅ `$obj?.Property` | Use explicit null checks in PS5.1 |
| **Pipeline Chain** | ❌ Not available | ✅ `cmd1 && cmd2` | Use separate statements in PS5.1 |
| **SecureString** | Fully supported (DPAPI) | Supported (less secure on non-Windows) | Use consistently, document limitations |
| **ForEach-Object -Parallel** | ❌ Not available | ✅ Available | Provide serial version for PS5.1 |
| **ConvertFrom-Json -AsHashtable** | ❌ Not available | ✅ Available (7.2+) | Manual conversion in PS5.1 |
| **Invoke-RestMethod Redirect** | `.BaseResponse.ResponseURI.Host` | `.BaseResponse.RequestMessage.RequestUri.Host` | Conditional logic based on `$PSVersionTable.PSVersion.Major` |
| **$IsWindows** | ❌ Not available | ✅ Available | Define `$IsWindows = $true` in PS5.1 |
| **Platform Support** | Windows only | Cross-platform | Use platform checks where needed |
| **Hashtable Creation** | Standard | Enhanced | Use standard syntax for compatibility |
| **Splatting** | ✅ Fully supported | ✅ Fully supported | Use extensively in both |


### Build Process: From Source to Distribution

**Goal:** Combine all separate .ps1 files into a single .psm1 for easy distribution.

**Build Script (`Build/Build-Module.ps1`):**
```powershell
<#
.SYNOPSIS
    Builds distribution-ready module files from source.

.DESCRIPTION
    Combines all .ps1 files from Private/, Public/, Classes/, Enums/ into single .psm1 files.
    Validates with PSScriptAnalyzer before building.

.EXAMPLE
    .\Build-Module.ps1 -Version PS5.1
    .\Build-Module.ps1 -Version PS7
    .\Build-Module.ps1 -Version All
#>
[CmdletBinding()]
param(
    [Parameter(Mandatory = $false)]
    [ValidateSet('PS5.1', 'PS7', 'All')]
    [string]$Version = 'All'
)

function Build-SingleModule {
    param(
        [string]$SourcePath,    # e.g., "PS5.1"
        [string]$ModuleName,    # e.g., "IdentityAuth"
        [string]$OutputPath     # e.g., "Distribution"
    )

    Write-Output "Building $ModuleName from $SourcePath..."

    # Validate source with PSScriptAnalyzer
    Write-Output "  Running PSScriptAnalyzer..."
    $analysisResults = Invoke-ScriptAnalyzer -Path $SourcePath -Recurse -Settings ../PSScriptAnalyzerSettings.psd1
    if ($analysisResults) {
        Write-Warning "PSScriptAnalyzer found issues. Fix before building!"
        $analysisResults | Format-Table -AutoSize
        return $false
    }

    # Create output directory
    $null = New-Item -Path $OutputPath -ItemType Directory -Force

    # Start building combined .psm1
    $combinedContent = @()

    # Add header
    $combinedContent += @"
<#
.SYNOPSIS
    $ModuleName - CyberArk Identity Authentication Module

.DESCRIPTION
    Authentication module for CyberArk Identity Security Platform Shared Services (ISPSS).
    Supports OAuth, UP, MFA, and OOBAUTHPIN authentication methods.

.NOTES
    Version:        2.0.0
    Generated:      $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
    Build Process:  Combined from source files in $SourcePath/
#>

#Requires -Version $(if ($ModuleName -eq 'IdentityAuth') {'5.1'} else {'7.0'})

# Set strict mode
Set-StrictMode -Version Latest

# Module-level variables
`$script:CurrentSession = `$null

"@

    # For PS7, add Classes first
    if ($ModuleName -eq 'IdentityAuth7') {
        Write-Output "  Adding Classes..."
        $classFiles = Get-ChildItem -Path "$SourcePath/Classes/*.ps1" -File | Sort-Object Name
        foreach ($file in $classFiles) {
            $combinedContent += "`n# Region: Class - $($file.BaseName)"
            $combinedContent += Get-Content -Path $file.FullName -Raw
            $combinedContent += "# EndRegion: Class - $($file.BaseName)`n"
        }

        Write-Output "  Adding Enums..."
        $enumFiles = Get-ChildItem -Path "$SourcePath/Enums/*.ps1" -File | Sort-Object Name
        foreach ($file in $enumFiles) {
            $combinedContent += "`n# Region: Enum - $($file.BaseName)"
            $combinedContent += Get-Content -Path $file.FullName -Raw
            $combinedContent += "# EndRegion: Enum - $($file.BaseName)`n"
        }
    }

    # Add Private functions
    Write-Output "  Adding Private functions..."
    $privateFiles = Get-ChildItem -Path "$SourcePath/Private/*.ps1" -File | Sort-Object Name
    foreach ($file in $privateFiles) {
        $combinedContent += "`n# Region: Private - $($file.BaseName)"
        $combinedContent += Get-Content -Path $file.FullName -Raw
        $combinedContent += "# EndRegion: Private - $($file.BaseName)`n"
    }

    # Add Public functions
    Write-Output "  Adding Public functions..."
    $publicFiles = Get-ChildItem -Path "$SourcePath/Public/*.ps1" -File | Sort-Object Name
    foreach ($file in $publicFiles) {
        $combinedContent += "`n# Region: Public - $($file.BaseName)"
        $combinedContent += Get-Content -Path $file.FullName -Raw
        $combinedContent += "# EndRegion: Public - $($file.BaseName)`n"
    }

    # Add module exports footer
    $publicFunctionNames = $publicFiles.BaseName
    $combinedContent += @"

# Export public functions
Export-ModuleMember -Function @(
    $(($publicFunctionNames | ForEach-Object { "'$_'" }) -join ",`n    ")
)
"@

    # Write combined file
    $outputFile = Join-Path $OutputPath "$ModuleName.psm1"
    $combinedContent | Out-File -FilePath $outputFile -Encoding UTF8 -Force
    Write-Output "  Created: $outputFile"

    # Copy manifest
    Copy-Item -Path "$SourcePath/$ModuleName.psd1" -Destination "$OutputPath/$ModuleName.psd1" -Force
    Write-Output "  Copied: $ModuleName.psd1"

    # Test import
    Write-Output "  Testing import..."
    Import-Module $outputFile -Force -ErrorAction Stop
    Remove-Module $ModuleName -ErrorAction SilentlyContinue

    Write-Output "  SUCCESS: $ModuleName built successfully!`n"
    return $true
}

# Main build logic
$rootPath = Split-Path -Parent $PSScriptRoot
$distPath = Join-Path $rootPath "Distribution"

if ($Version -in 'PS5.1', 'All') {
    $success = Build-SingleModule -SourcePath (Join-Path $rootPath "PS5.1") -ModuleName "IdentityAuth" -OutputPath $distPath
    if (-not $success) { exit 1 }
}

if ($Version -in 'PS7', 'All') {
    $success = Build-SingleModule -SourcePath (Join-Path $rootPath "PS7") -ModuleName "IdentityAuth7" -OutputPath $distPath
    if (-not $success) { exit 1 }
}

# Copy README for end users
Copy-Item -Path (Join-Path $rootPath "README.md") -Destination (Join-Path $distPath "README.md") -Force

Write-Output "="*80
Write-Output "BUILD COMPLETE!"
Write-Output "Distribution files ready in: $distPath"
Write-Output "="*80
```

**VS Code Build Task (`.vscode/tasks.json`):**
```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Build Module - All",
            "type": "shell",
            "command": "pwsh",
            "args": ["-File", "${workspaceFolder}/Build/Build-Module.ps1", "-Version", "All"],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "problemMatcher": []
        },
        {
            "label": "Build Module - PS5.1 Only",
            "type": "shell",
            "command": "pwsh",
            "args": ["-File", "${workspaceFolder}/Build/Build-Module.ps1", "-Version", "PS5.1"],
            "problemMatcher": []
        },
        {
            "label": "Build Module - PS7 Only",
            "type": "shell",
            "command": "pwsh",
            "args": ["-File", "${workspaceFolder}/Build/Build-Module.ps1", "-Version", "PS7"],
            "problemMatcher": []
        }
    ]
}
```

**Build Workflow:**
```
1. DEVELOP in PS5.1/ or PS7/ folders (organized .ps1 files)
   ↓
2. RUN PSScriptAnalyzer (zero violations required)
   ↓
3. RUN Build-Module.ps1 (combines into single .psm1)
   ↓
4. OUTPUT to Distribution/ folder
   ↓
5. TEST Distribution/IdentityAuth.psm1 import
   ↓
6. DELIVER Distribution/ files to end users
```

**Benefits:**
- ✅ **Dev**: Organized, maintainable source code
- ✅ **Build**: Automated, validated, repeatable process
- ✅ **Delivery**: Single .psm1 + .psd1 for easy import
- ✅ **VS Code**: Press `Ctrl+Shift+B` to build instantly

---

### Module Exports

**IdentityAuth.psd1 / IdentityAuth7.psd1:**
```powershell
@{
    ModuleVersion = '2.0.0'
    GUID = '12345678-1234-1234-1234-123456789012'  # Generate unique GUID
    Author = 'CyberArk'
    CompanyName = 'CyberArk'
    Copyright = '(c) 2026 CyberArk. All rights reserved.'
    Description = 'Authentication module for CyberArk Identity Security Platform Shared Services (ISPSS)'
    PowerShellVersion = '5.1'  # or '7.0' for IdentityAuth7.psd1

    FunctionsToExport = @(
        'Get-IdentityHeader',
        'Get-IdentityURL',
        'Test-IdentityToken',
        'Clear-IdentitySession',
        'Get-IdentitySession'
    )

    VariablesToExport = @()  # No variables exported
    AliasesToExport = @()    # No aliases

    PrivateData = @{
        PSData = @{
            Tags = @('CyberArk', 'Identity', 'Authentication', 'PrivilegeCloud', 'PAM', 'ISPSS')
            LicenseUri = 'https://github.com/cyberark/epv-api-scripts/blob/main/LICENSE'
            ProjectUri = 'https://github.com/cyberark/epv-api-scripts'
            ReleaseNotes = 'v2.0.0: Complete rewrite with OOBAUTHPIN support, OAuth modernization, PS7 classes/enums'
        }
    }
}
```

---

## Session State Management

### $script:CurrentSession Structure

#### PowerShell 7 Version (Class)

```powershell
class IdentitySession {
    # Core authentication data
    [string]$Token                          # Bearer token
    [datetime]$TokenExpiry                  # Calculated expiry timestamp
    [string]$IdentityURL                    # https://tenant.id.cyberark.cloud
    [string]$PCloudURL                      # https://subdomain.privilegecloud.cyberark.cloud/PasswordVault

    # User and session metadata
    [string]$Username                       # Authenticated username
    [string]$SessionId                      # Identity SessionId from StartAuthentication
    [AuthenticationMechanism]$AuthMethod    # Method used (OAuth, UP, OOBAUTHPIN, etc.)

    # Optional stored credentials (OAuth only for auto-refresh)
    [PSCredential]$StoredCredentials        # Securely stored OAuth credentials

    # Additional metadata
    [hashtable]$Metadata = @{
        CreatedAt = [datetime]::Now
        LastRefreshed = [datetime]::Now
        RefreshCount = 0
        PCloudVersion = $null
        TenantId = $null
    }

    # Constructor
    IdentitySession() { }

    IdentitySession([hashtable]$Properties) {
        $this.Token = $Properties.Token
        $this.TokenExpiry = $Properties.TokenExpiry
        $this.IdentityURL = $Properties.IdentityURL
        $this.PCloudURL = $Properties.PCloudURL ?? ''
        $this.Username = $Properties.Username
        $this.SessionId = $Properties.SessionId ?? ''
        $this.AuthMethod = $Properties.AuthMethod
        $this.StoredCredentials = $Properties.StoredCredentials
    }

    # Methods
    [bool] IsExpired() {
        return (Get-Date) -gt $this.TokenExpiry
    }

    [bool] IsExpiringSoon([int]$ThresholdSeconds = 60) {
        $expiryThreshold = (Get-Date).AddSeconds($ThresholdSeconds)
        return $this.TokenExpiry -lt $expiryThreshold
    }

    [void] Refresh() {
        if ($this.AuthMethod -eq [AuthenticationMechanism]::OAuth) {
            if ($null -ne $this.StoredCredentials) {
                Write-Verbose "Auto-refreshing OAuth token"

                $ClientId = $this.StoredCredentials.UserName
                $bstr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($this.StoredCredentials.Password)
                $ClientSecret = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($bstr)

                try {
                    $body = "grant_type=client_credentials&client_id=$ClientId&client_secret=$ClientSecret"
                    $oauthParams = @{
                        Uri = "$($this.IdentityURL)/OAuth2/Token/$ClientId"
                        Method = 'Post'
                        ContentType = 'application/x-www-form-urlencoded'
                        Body = $body
                        ErrorAction = 'Stop'
                    }
                    $response = Invoke-RestMethod @oauthParams

                    $this.Token = $response.access_token
                    $this.TokenExpiry = (Get-Date).AddSeconds($response.expires_in)
                    $this.Metadata.LastRefreshed = Get-Date
                    $this.Metadata.RefreshCount++

                    Write-Verbose "OAuth token refreshed successfully (Refresh count: $($this.Metadata.RefreshCount))"
                } catch {
                    throw "Failed to refresh OAuth token: $($_.Exception.Message)"
                } finally {
                    if ($bstr) {
                        [System.Runtime.InteropServices.Marshal]::ZeroFreeBSTR($bstr)
                    }
                    $ClientSecret = $null
                }
            } else {
                throw "Cannot refresh: OAuth credentials not stored in session"
            }
        } else {
            throw "Cannot auto-refresh: AuthMethod '$($this.AuthMethod)' requires manual user interaction"
        }
    }

    [hashtable] GetAuthHeader() {
        if ($this.IsExpired()) {
            throw "Token expired. Re-authentication required."
        }
        return @{
            'Authorization' = "Bearer $($this.Token)"
            'X-IDAP-NATIVE-CLIENT' = 'true'
        }
    }

    [void] Dispose() {
        Write-Verbose "Disposing Identity session for user: $($this.Username)"

        # Call logout endpoint
        try {
            $logoutUrl = "$($this.IdentityURL)/Security/logout"
            $logoutParams = @{
                Uri = $logoutUrl
                Method = 'Post'
                Headers = $this.GetAuthHeader()
                ErrorAction = 'SilentlyContinue'
            }
            Invoke-RestMethod @logoutParams | Out-Null
            Write-Verbose "Logout API call successful"
        } catch {
            Write-Verbose "Logout API call failed: $($_.Exception.Message)"
        }

        # Clear sensitive data
        $this.Token = $null
        $this.StoredCredentials = $null
        $this.SessionId = $null
        Write-Verbose "Session disposed"
    }
}

# Script-scope variable to store current session
$script:CurrentSession = $null
```

#### PowerShell 5.1 Version (Hashtable)

```powershell
# Script-scope hashtable to store current session
$script:CurrentSession = @{
    Token = $null
    TokenExpiry = $null
    IdentityURL = $null
    PCloudURL = $null
    Username = $null
    SessionId = $null
    AuthMethod = $null
    StoredCredentials = $null
    Metadata = @{
        CreatedAt = $null
        LastRefreshed = $null
        RefreshCount = 0
        PCloudVersion = $null
        TenantId = $null
    }
}

# Helper functions to mimic class methods
function Test-SessionExpired {
    param([hashtable]$Session)
    return (Get-Date) -gt $Session.TokenExpiry
}

function Test-SessionExpiringSoon {
    param(
        [hashtable]$Session,
        [int]$ThresholdSeconds = 60
    )
    $expiryThreshold = (Get-Date).AddSeconds($ThresholdSeconds)
    return $Session.TokenExpiry -lt $expiryThreshold
}

function Update-IdentitySession {
    param([hashtable]$Session)

    if ($Session.AuthMethod -eq 'OAuth') {
        if ($null -ne $Session.StoredCredentials) {
            # Same OAuth refresh logic as PS7 class method
            # ... implementation ...
        } else {
            throw "Cannot refresh: OAuth credentials not stored"
        }
    } else {
        throw "Cannot auto-refresh: Manual re-authentication required"
    }
}

function Get-SessionAuthHeader {
    param([hashtable]$Session)

    if (Test-SessionExpired -Session $Session) {
        throw "Token expired. Re-authentication required."
    }
    return @{
        'Authorization' = "Bearer $($Session.Token)"
        'X-IDAP-NATIVE-CLIENT' = 'true'
    }
}

function Remove-IdentitySessionData {
    param([hashtable]$Session)

    Write-Verbose "Disposing Identity session for user: $($Session.Username)"

    # Call logout endpoint
    try {
        $logoutUrl = "$($Session.IdentityURL)/Security/logout"
        $logoutParams = @{
            Uri = $logoutUrl
            Method = 'Post'
            Headers = (Get-SessionAuthHeader -Session $Session)
            ErrorAction = 'SilentlyContinue'
        }
        Invoke-RestMethod @logoutParams | Out-Null
        Write-Verbose "Logout API call successful"
    } catch {
        Write-Verbose "Logout API call failed: $($_.Exception.Message)"
    }

    # Clear sensitive data
    $Session.Token = $null
    $Session.StoredCredentials = $null
    $Session.SessionId = $null
    Write-Verbose "Session disposed"
}
```

### Session Security Considerations

#### Token Storage
- **In-Memory Only**: Tokens stored only in `$script:CurrentSession`, never written to disk
- **Process Isolation**: PowerShell process memory isolated from other processes
- **Automatic Cleanup**: `Dispose()` method/function clears sensitive data
- **No Global Scope**: Session not exported to global scope, preventing accidental exposure

#### Credential Storage (OAuth Only)
- **PSCredential Object**: Uses SecureString for password portion
- **Windows DPAPI**: SecureString encrypted with user's Windows credentials (PS 5.1/Windows)
- **Limited Exposure**: Only stored when necessary for auto-refresh
- **User Control**: Can be disabled via parameters

#### Session Lifetime
- **Token Expiry**: Strictly enforced, no usage after expiry
- **Auto-Refresh**: Only for OAuth with stored credentials
- **Manual Re-auth**: Required for MFA-based authentication
- **Session Timeout**: Follows Identity platform timeout policies

---

## Return Value Structure

### Get-IdentityHeader Return Value

**Type:** `System.Collections.Hashtable`

**Structure:** Hashtable with authorization headers

**Example:**
```powershell
$headers = Get-IdentityHeader -OAuthCreds $creds -PCloudURL 'https://subdomain.privilegecloud.cyberark.cloud/PasswordVault'
# Returns:
# Name                           Value
# ----                           -----
# X-IDAP-NATIVE-CLIENT           true
# Authorization                  Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6...
```

**Usage Example:**
```powershell
# Get headers
$headers = Get-IdentityHeader -OAuthCreds $creds -PCloudURL 'https://subdomain.privilegecloud.cyberark.cloud/PasswordVault'

# Use with Accounts_Onboard_Utility.ps1
.\Accounts_Onboard_Utility.ps1 -PVWAURL 'https://subdomain.privilegecloud.cyberark.cloud/PasswordVault' -logonToken $headers

# Use with any Privilege Cloud API
$accountsUrl = 'https://subdomain.privilegecloud.cyberark.cloud/PasswordVault/PasswordVault/API/Accounts'
$accounts = Invoke-RestMethod -Uri $accountsUrl -Method Get -Headers $headers
```

**Hashtable Contents:**
```powershell
@{
    'Authorization'        = 'Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6...'
    'X-IDAP-NATIVE-CLIENT' = 'true'
}
```

### Compatibility with Accounts_Onboard_Utility.ps1

The Accounts_Onboard_Utility.ps1 script accepts the hashtable returned by `Get-IdentityHeader`:

```powershell
$headers = Get-IdentityHeader -OAuthCreds $creds -PCloudURL 'https://subdomain.privilegecloud.cyberark.cloud/PasswordVault'
$pvwaUrl = 'https://subdomain.privilegecloud.cyberark.cloud/PasswordVault'

# Pass the hashtable to -logonToken
.\Accounts_Onboard_Utility.ps1 -PVWAURL $pvwaUrl -logonToken $headers
```

**All epv-api-scripts that use `-logonToken` accept the hashtable format.**

**Note:** This format is specifically for **Privilege Cloud (PCloud)** which uses Bearer tokens. On-premises PVWA installations use session tokens from CyberArk Authentication, not Identity authentication.

---

## Security Architecture

### Defense in Depth Layers

```mermaid
graph TD
    A[User Input] -->|1. Validation| B[Parameter Validation<br/>ValidateNotNullOrEmpty<br/>ValidatePattern<br/>ValidateScript]
    B -->|2. Secure Storage| C[PSCredential<br/>SecureString<br/>DPAPI Encryption]
    C -->|3. Secure Transport| D[HTTPS Only<br/>TLS 1.2+<br/>Certificate Validation]
    D -->|4. Authentication| E[Identity API<br/>OAuth/MFA/OOBAUTHPIN]
    E -->|5. Token Management| F[In-Memory Storage<br/>Script Scope Isolation]
    F -->|6. Access Control| G[No Global Scope<br/>Controlled Exports]
    G -->|7. Logging| H[Sensitive Data Masking<br/>Opt-in Unmasked Logging]
    H -->|8. Cleanup| I[Dispose Pattern<br/>Finally Blocks<br/>Clear Session]
```

### Threat Model and Mitigations

| Threat | Impact | Mitigation | Implementation |
|--------|--------|-----------|----------------|
| **Credential Exposure in Memory** | High | Use SecureString, minimize plaintext lifetime | PSCredential objects, BSTR only when needed, ZeroFreeBSTR in finally |
| **Token Interception (MITM)** | High | HTTPS only, TLS 1.2+ | `[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12` |
| **Token Theft from Memory** | High | In-memory only, script scope, auto-cleanup | `$script:CurrentSession`, Dispose() method, no disk writes |
| **Log File Exposure** | Medium | Sensitive data masking, file permissions | Mask passwords/tokens/secrets in logs, document secure log storage |
| **Replay Attacks** | Medium | Token expiry, session validation | Strict expiry enforcement, IsExpired() checks |
| **Man-in-Middle** | High | Certificate validation | Enabled by default, disable only for testing with warning |
| **Privilege Escalation** | Medium | Least privilege tokens | OAuth scopes, Identity RBAC policies |
| **Session Hijacking** | Medium | SessionId validation, timeout | Track SessionId, enforce platform timeouts |
| **Password in Command History** | Medium | Use PSCredential, avoid plain text params | Prefer PSCredential, SecureString over plain strings |
| **Cross-Script Token Leakage** | Low | Script scope isolation | No global scope, controlled exports |

### Secure Credential Handling Workflow

```mermaid
sequenceDiagram
    participant User
    participant Script
    participant PSCredential
    participant SecureString
    participant BSTR
    participant API

    User->>Script: Provide credentials
    Script->>PSCredential: Create PSCredential object
    PSCredential->>SecureString: Store password as SecureString (DPAPI encrypted)

    Script->>Script: Need plaintext for API
    Script->>BSTR: SecureStringToBSTR(SecureString)
    BSTR->>Script: Return BSTR pointer
    Script->>Script: PtrToStringAuto(BSTR)
    Script->>API: POST with plaintext password
    API-->>Script: Response

    Script->>BSTR: ZeroFreeBSTR(BSTR) - Clear memory
    Script->>Script: Set plaintext variable to $null
    Note over Script,API: Plaintext lifetime < 1 second
```

---

## API Integration

### Identity API Endpoints Used

| Endpoint | Method | Purpose | Request Body | Response | Auth Required |
|----------|--------|---------|--------------|----------|---------------|
| `/oauth2/platformtoken/` or `/OAuth2/Token/ClientId` | POST | OAuth token generation | grant_type, client_id, client_secret (form-urlencoded) | access_token, token_type, expires_in | No (uses client creds) |
| `/Security/StartAuthentication` | POST | Initiate authentication session | User, Version (JSON) | SessionId, Challenges, IdpRedirectShortUrl (if OOBAUTHPIN), TenantId | No |
| `/Security/AdvanceAuthentication` | POST | Answer challenge/submit PIN | SessionId, MechanismId, Action, Answer (JSON) | Success, Token, Summary | No |
| `/Security/logout` | POST | End session | None | Success message | Yes (Bearer token) |

### API Request/Response Examples

#### OAuth Token Request

**Request:**
```http
POST /OAuth2/Token/myClientId HTTP/1.1
Host: tenant.id.cyberark.cloud
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials&client_id=myClientId&client_secret=myClientSecret
```

**Response (Success):**
```json
{
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6...",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

**Response (Error - 401):**
```json
{
  "error": "invalid_client",
  "error_description": "Client authentication failed"
}
```

#### StartAuthentication Request (OOBAUTHPIN)

**Request:**
```http
POST /Security/StartAuthentication HTTP/1.1
Host: tenant.id.cyberark.cloud
Content-Type: application/json
X-IDAP-NATIVE-CLIENT: true
OobIdPAuth: true

{
  "User": "admin@company.com",
  "Version": "1.0"
}
```

**Response (OOBAUTHPIN Available):**
```json
{
  "success": true,
  "Result": {
    "SessionId": "abc123...",
    "TenantId": "tenant123",
    "IdpRedirectShortUrl": "https://short.cyberark.cloud/abc123",
    "IdpLoginSessionId": "saml-session-xyz789"
  }
}
```

**Response (Standard Challenges):**
```json
{
  "success": true,
  "Result": {
    "SessionId": "abc123...",
    "TenantId": "tenant123",
    "Challenges": [
      {
        "Mechanisms": [
          {
            "MechanismId": "mech123",
            "Name": "UP",
            "AnswerType": "Text",
            "PromptMechChosen": "Password"
          },
          {
            "MechanismId": "mech456",
            "Name": "PF",
            "AnswerType": "StartTextOob",
            "PromptMechChosen": "Push to mobile"
          }
        ]
      }
    ]
  }
}
```

#### AdvanceAuthentication Request (OOBAUTHPIN)

**Request:**
```http
POST /Security/AdvanceAuthentication HTTP/1.1
Host: tenant.id.cyberark.cloud
Content-Type: application/json
X-IDAP-NATIVE-CLIENT: true

{
  "SessionId": "saml-session-xyz789",
  "MechanismId": "OOBAUTHPIN",
  "Action": "Answer",
  "Answer": "123456"
}
```

**Response (Success with Token):**
```json
{
  "success": true,
  "Result": {
    "Summary": "LoginSuccess",
    "Token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6...",
    "UserId": "user123",
    "User": "admin@company.com"
  }
}
```

**Response (Success with More Challenges):**
```json
{
  "success": true,
  "Result": {
    "Summary": "NewPackage",
    "SessionId": "abc123...",
    "Challenges": [
      {
        "Mechanisms": [
          {
            "MechanismId": "mech789",
            "Name": "OTP",
            "AnswerType": "Text",
            "PromptMechChosen": "Enter OTP code"
          }
        ]
      }
    ]
  }
}
```

### Error Handling Patterns

```powershell
function Invoke-IdentityAPI {
    param(
        [string]$Uri,
        [string]$Method,
        [object]$Body,
        [hashtable]$Headers
    )

    try {
        $invokeParams = @{
            Uri = $Uri
            Method = $Method
            ErrorAction = 'Stop'
        }

        if ($Body) {
            $invokeParams.Body = $Body
            $invokeParams.ContentType = 'application/json'
        }

        if ($Headers) {
            $invokeParams.Headers = $Headers
        }

        Write-Verbose "API Call: $Method $Uri"
        $response = Invoke-RestMethod @invokeParams
        Write-Verbose "API Response: Success"

        return $response

    } catch {
        $statusCode = $null
        $errorMessage = $_.Exception.Message

        if ($_.Exception.Response) {
            $statusCode = $_.Exception.Response.StatusCode.value__
        }

        # Parse error details
        $errorDetails = $null
        if ($_.ErrorDetails.Message) {
            try {
                $errorDetails = $_.ErrorDetails.Message | ConvertFrom-Json
            } catch {
                $errorDetails = $_.ErrorDetails.Message
            }
        }

        # Map HTTP status codes to meaningful errors
        $mappedError = switch ($statusCode) {
            401 { "Authentication failed: Invalid credentials or token expired" }
            403 { "Access denied: Insufficient permissions" }
            404 { "Endpoint not found: Check URL and API version" }
            429 { "Rate limit exceeded: Wait and retry" }
            500 { "Server error: $($errorDetails.message ?? $errorMessage)" }
            503 { "Service unavailable: Identity platform may be down" }
            default { "API error ($statusCode): $($errorDetails.message ?? $errorMessage)" }
        }

        Write-Verbose "API Error: $mappedError"

        $errorRecord = [System.Management.Automation.ErrorRecord]::new(
            [System.Exception]::new($mappedError),
            "IdentityAPI_$statusCode",
            [System.Management.Automation.ErrorCategory]::InvalidOperation,
            $Uri
        )
        $PSCmdlet.ThrowTerminatingError($errorRecord)
    }
}
```

---

## Conclusion

This architecture design provides comprehensive technical specifications for the modernized Identity Authentication module. The detailed process flows, class structures, and API integration patterns ensure clear understanding of the system's behavior.

Key architectural decisions:
1. **Dual Module Approach**: Separate PS5.1 and PS7 modules for maximum compatibility and feature utilization
2. **Session State Management**: Centralized `$script:CurrentSession` with automatic OAuth refresh
3. **Security First**: Defense in depth, secure credential handling, sensitive data masking
4. **Standards Compliance**: Zero PSScriptAnalyzer violations, extensive splatting, proper error handling
5. **User Experience**: Single-step authentication, clear instructions, helpful error messages

The architecture supports enterprise requirements while remaining accessible to administrators and developers. The clear separation between public and private functions, along with detailed type definitions, provides a solid foundation for implementation and future enhancements.
